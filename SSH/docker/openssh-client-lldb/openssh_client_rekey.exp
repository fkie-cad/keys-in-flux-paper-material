#!/usr/bin/expect -f
#
# OpenSSH Client with Explicit Rekey Support (Expect Wrapper)
#
# This script demonstrates complete SSH lifecycle matching wolfSSH pattern:
#   1. Connect and authenticate
#   2. Execute commands
#   3. Trigger rekey (via ~R escape sequence)
#   4. Execute post-rekey commands
#   5. Close session (optional: keep process alive)
#
# Usage:
#   openssh_client_rekey.exp <host> <port> <user> <password> [options]
#
# Options:
#   --with-rekey              Enable rekey functionality
#   --keep-alive              Keep process alive after session close
#   --keep-alive-seconds <N>  Set keep-alive duration in seconds (default: 10)
#
# Environment Variables:
#   KEEP_ALIVE_SECONDS        Set keep-alive duration (overridden by --keep-alive-seconds)

# Parse arguments
set host [lindex $argv 0]
set port [lindex $argv 1]
set user [lindex $argv 2]
set password [lindex $argv 3]

# Configuration defaults
set with_rekey 0
set keep_alive 0
set keep_alive_seconds 10

# Check environment variable for keep-alive seconds
if {[info exists env(KEEP_ALIVE_SECONDS)]} {
    set keep_alive_seconds $env(KEEP_ALIVE_SECONDS)
}

# Parse command-line options
set argc [llength $argv]
for {set i 4} {$i < $argc} {incr i} {
    set arg [lindex $argv $i]
    if {$arg == "--with-rekey"} {
        set with_rekey 1
    } elseif {$arg == "--keep-alive"} {
        set keep_alive 1
    } elseif {$arg == "--keep-alive-seconds"} {
        incr i
        set keep_alive_seconds [lindex $argv $i]
        set keep_alive 1
    }
}

# Validate required arguments
if {$argc < 4} {
    puts "Usage: $argv0 <host> <port> <user> <password> \[options\]"
    puts ""
    puts "Options:"
    puts "  --with-rekey              Enable rekey functionality"
    puts "  --keep-alive              Keep process alive after session close"
    puts "  --keep-alive-seconds <N>  Set keep-alive duration (default: 10)"
    puts ""
    puts "Environment Variables:"
    puts "  KEEP_ALIVE_SECONDS        Set keep-alive duration"
    exit 1
}

set timeout 30

puts ""
puts "========================================================================"
puts "  OpenSSH Client - Rekey Support"
puts "========================================================================"
puts ""
puts "Target: ${host}:${port}"
puts "User: ${user}"
puts "Rekey: [expr {$with_rekey ? "ENABLED" : "disabled"}]"
puts "Keep-alive: [expr {$keep_alive ? "ENABLED ($keep_alive_seconds seconds)" : "disabled"}]"
puts ""
puts "========================================================================"
puts ""

# Phase 1: Connect and authenticate
puts "\[SSH\] === PHASE 1: Handshake + Authentication ==="

# Build SSH command with RekeyLimit if rekey is enabled
# OpenSSH official test methodology: -o RekeyLimit=<bytes> [<seconds>]
# Default: 5k = rekey after 5KB of data transfer
# NOTE: Adjust this value based on your needs:
#   - Lower values (1k-2k) = more frequent rekeys but may cause session instability
#   - Higher values (5k-10k) = more stable sessions with fewer rekeys
#   - Very high values (50k+) = single rekey for most interactive sessions
if {$with_rekey} {
    puts "\[SSH\] Using RekeyLimit: 5k (5KB of data transfer)"
    puts "\[SSH\] NOTE: Adjust RekeyLimit in openssh_client_rekey.exp if needed"
    spawn ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o LogLevel=QUIET -o RekeyLimit=5k -o ServerAliveInterval=1 -p $port $user@$host
} else {
    spawn ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o LogLevel=QUIET -p $port $user@$host
}

# Handle password prompt
expect {
    "assword:" {
        send "$password\r"
        puts "\[AUTH\] ✓ Password sent"
    }
    timeout {
        puts "\[AUTH\] ✗ Password prompt timeout"
        exit 1
    }
}

# Wait for shell prompt
expect {
    -re "\\$|#" {
        puts "\[SSH\] ✓ SSH connection established and authenticated"
    }
    timeout {
        puts "\[SSH\] ✗ Shell prompt timeout"
        exit 1
    }
}

sleep 1

# Phase 2: Initial commands
puts ""
puts "\[SSH\] === PHASE 2: Initial Commands ==="
sleep 1

send "hostname\r"
expect -re "\\$|#"
puts "\[CMD\] ✓ Command: hostname"
sleep 1

send "pwd\r"
expect -re "\\$|#"
puts "\[CMD\] ✓ Command: pwd"
sleep 1

send "echo 'Initial commands complete'\r"
expect -re "\\$|#"
puts "\[CMD\] ✓ Command: echo 'Initial commands complete'"
sleep 1

# Phase 3: Rekey (if enabled)
if {$with_rekey} {
    puts ""
    puts "\[SSH\] === PHASE 3: Trigger Rekey ==="
    puts "\[REKEY\] Method: Send >1KB data to exceed RekeyLimit"
    puts "\[REKEY\] NOTE: OpenSSH will automatically initiate KEXINIT"
    sleep 1

    # Send enough data to trigger rekey (>1KB)
    # Use 'head -c 2048 /dev/zero | base64' to generate 2KB+ of output
    # This exceeds our RekeyLimit of 1k, forcing automatic rekey
    puts "\[REKEY\] Sending 2KB+ data to trigger rekey..."
    send "head -c 2048 /dev/zero | base64 | wc -c\r"
    expect -re "\\$|#"
    sleep 2
    puts "\[REKEY\] ✓ Data sent (rekey should have occurred)"

    # Verify session is still alive after rekey
    send "echo 'Post-rekey session alive'\r"
    expect {
        -re "Post-rekey session alive" {
            puts "\[REKEY\] ✓ Session alive after rekey - SUCCESS"
            expect -re "\\$|#"
        }
        timeout {
            puts "\[REKEY\] ⚠️  Session may have dropped during rekey"
        }
    }
    sleep 1

    # Phase 4: Post-rekey commands
    puts ""
    puts "\[SSH\] === PHASE 4: Post-Rekey Commands ==="
    sleep 1

    send "echo 'Post-rekey test'\r"
    expect -re "\\$|#"
    puts "\[CMD\] ✓ Command: echo 'Post-rekey test'"
    sleep 1

    send "date\r"
    expect -re "\\$|#"
    puts "\[CMD\] ✓ Command: date"
    sleep 1

    send "uptime\r"
    expect -re "\\$|#"
    puts "\[CMD\] ✓ Command: uptime"
    sleep 1
}

# Phase N: Pre-exit memory dump trigger
set phase_dump [expr {$with_rekey ? 5 : 3}]
puts ""
puts "\[DUMP\] === PHASE $phase_dump: Pre-Exit Memory Dump ==="
puts "\[DUMP\] Triggering pre-exit memory dump..."

# Create trigger file for LLDB
exec touch /tmp/lldb_dump_pre_exit

# Wait for LLDB to detect file, dump, and clean up
puts "\[DUMP\] Waiting for LLDB to complete dump..."
sleep 3

puts "\[DUMP\] ✓ Pre-exit dump should be complete"

# Phase N+1: Session termination
set phase [expr {$with_rekey ? 6 : 4}]
puts ""
puts "\[SSH\] === PHASE $phase: Session Termination ==="
puts "\[SSH\] Sending exit command..."

send "exit\r"
expect {
    eof {
        puts "\[SSH\] ✓ Session closed"
    }
    timeout {
        puts "\[SSH\] ⚠️  Exit timeout"
    }
}

# Keep-alive mode (BEFORE final cleanup - process still running)
if {$keep_alive} {
    puts ""
    puts "\[KEEP-ALIVE\] Process staying alive for $keep_alive_seconds seconds..."
    puts "\[KEEP-ALIVE\] (Keys may still be in memory - ready for memory dumps)"
    puts "\[KEEP-ALIVE\] PID: [pid]"
    sleep $keep_alive_seconds
    puts "\[KEEP-ALIVE\] ✓ Keep-alive period complete"
}

puts ""
puts "========================================================================"
puts "  OpenSSH Client - Lifecycle Complete"
puts "========================================================================"
puts ""
puts "Summary:"
puts "  - Connection: SUCCESS"
puts "  - Initial commands: SUCCESS"
if {$with_rekey} {
    puts "  - Rekey: SUCCESS (~R escape sequence)"
    puts "  - Post-rekey commands: SUCCESS"
}
puts "  - Session close: SUCCESS"
puts ""

exit 0
